{"version":3,"sources":["../../../../../src/components/Virtualized/utils/CellSizeAndPositionManager.ts"],"names":["LinearLayoutVector","CellSizeAndPositionManager","constructor","cellCount","cellSizeGetter","estimatedCellSize","_cellSizeGetter","_cellCount","_estimatedCellSize","_layoutVector","setLength","setDefaultSize","areOffsetsAdjusted","configure","getCellCount","getEstimatedCellSize","getLastMeasuredIndex","_lastMeasuredIndex","getOffsetAdjustment","getSizeAndPositionOfCell","index","Error","vector","token","i","size","undefined","setItemSize","Math","min","offset","start","getItemSize","getSizeAndPositionOfLastMeasuredCell","getTotalSize","lastIndex","end","getUpdatedOffsetForIndex","align","containerSize","currentOffset","targetIndex","datum","maxOffset","minOffset","idealOffset","max","totalSize","getVisibleCellRange","params","_findNearestCell","stop","resetCell","isNaN","targetOffset","nearestCellIndex","indexOf"],"mappings":"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","sourcesContent":["/* eslint-disable */\n\nimport LinearLayoutVector from 'linear-layout-vector';\nimport { Alignment, CellSizeGetter, VisibleCellRange } from '../types';\n\ninterface CellSizeAndPositionManagerParams {\n  cellCount: number,\n  cellSizeGetter: CellSizeGetter,\n  estimatedCellSize: number\n}\n\ninterface ConfigureParams {\n  cellCount: number,\n  estimatedCellSize: number,\n  cellSizeGetter: CellSizeGetter\n}\n\ninterface GetUpdatedOffsetForIndex {\n  align: Alignment,\n  containerSize: number,\n  currentOffset: number,\n  targetIndex: number\n}\n\ninterface GetVisibleCellRangeParams {\n  containerSize: number,\n  offset: number\n}\n\ninterface SizeAndPositionData {\n  offset: number,\n  size: number\n}\n\n/**\n * Just-in-time calculates and caches size and position information for a collection of cells.\n */\n\nexport default class CellSizeAndPositionManager {\n  // Cache of size and position data for cells, mapped by cell index.\n  // Note that invalid values may exist in this map so only rely on cells up to this._lastMeasuredIndex\n  _layoutVector;\n\n  // Measurements for cells up to this index can be trusted; cells afterward should be estimated.\n  _lastMeasuredIndex = -1;\n\n  _cellCount: number;\n  _cellSizeGetter: CellSizeGetter;\n  _estimatedCellSize: number;\n\n  constructor({ cellCount, cellSizeGetter, estimatedCellSize }: CellSizeAndPositionManagerParams) {\n    this._cellSizeGetter = cellSizeGetter;\n    this._cellCount = cellCount;\n    this._estimatedCellSize = estimatedCellSize;\n    this._layoutVector = new LinearLayoutVector();\n    this._layoutVector.setLength(cellCount);\n    this._layoutVector.setDefaultSize(estimatedCellSize);\n  }\n\n  areOffsetsAdjusted() {\n    return false;\n  }\n\n  configure({ cellCount, estimatedCellSize, cellSizeGetter }: ConfigureParams) {\n    this._cellCount = cellCount;\n    this._estimatedCellSize = estimatedCellSize;\n    this._cellSizeGetter = cellSizeGetter;\n    this._layoutVector.setLength(cellCount);\n    this._layoutVector.setDefaultSize(estimatedCellSize);\n  }\n\n  getCellCount(): number {\n    return this._cellCount;\n  }\n\n  getEstimatedCellSize(): number {\n    return this._estimatedCellSize;\n  }\n\n  getLastMeasuredIndex(): number {\n    return this._lastMeasuredIndex;\n  }\n\n  getOffsetAdjustment() {\n    return 0;\n  }\n\n  /**\n   * This method returns the size and position for the cell at the specified index.\n   * It just-in-time calculates (or used cached values) for cells leading up to the index.\n   */\n  getSizeAndPositionOfCell(index: number): SizeAndPositionData {\n    if (index < 0 || index >= this._cellCount) {\n      throw Error(`Requested index ${index} is outside of range 0..${this._cellCount}`);\n    }\n    const vector = this._layoutVector;\n    if (index > this._lastMeasuredIndex) {\n      const token = { index: this._lastMeasuredIndex + 1 };\n\n      for (let i = token.index; i <= index; token.index = ++i) {\n        const size = this._cellSizeGetter(token);\n        // undefined or NaN probably means a logic error in the size getter.\n        // null means we're using CellMeasurer and haven't yet measured a given index.\n        if (size === undefined || size !== size) {\n          throw Error(`Invalid size returned for cell ${i} of value ${size}`);\n        } else if (size !== null) {\n          vector.setItemSize(i, size);\n        }\n      }\n      this._lastMeasuredIndex = Math.min(index, this._cellCount - 1);\n    }\n\n    return {\n      offset: vector.start(index),\n      size: vector.getItemSize(index)\n    };\n  }\n\n  getSizeAndPositionOfLastMeasuredCell(): SizeAndPositionData {\n    const index = this._lastMeasuredIndex;\n    if (index <= 0) {\n      return {\n        offset: 0,\n        size: 0\n      };\n    }\n    const vector = this._layoutVector;\n    return {\n      offset: vector.start(index),\n      size: vector.getItemSize(index)\n    };\n  }\n\n  /**\n   * Total size of all cells being measured.\n   * This value will be completely estimated initially.\n   * As cells are measured, the estimate will be updated.\n   */\n  getTotalSize(): number {\n    const lastIndex = this._cellCount - 1;\n    return lastIndex >= 0 ? this._layoutVector.end(lastIndex) : 0;\n  }\n\n  /**\n   * Determines a new offset that ensures a certain cell is visible, given the current offset.\n   * If the cell is already visible then the current offset will be returned.\n   * If the current offset is too great or small, it will be adjusted just enough to ensure the specified index is visible.\n   *\n   * @param align Desired alignment within container; one of \"auto\" (default), \"start\", or \"end\"\n   * @param containerSize Size (width or height) of the container viewport\n   * @param currentOffset Container's current (x or y) offset\n   * @param totalSize Total size (width or height) of all cells\n   * @return Offset to use to ensure the specified cell is visible\n   */\n  getUpdatedOffsetForIndex({\n    align = 'auto',\n    containerSize,\n    currentOffset,\n    targetIndex\n  }: GetUpdatedOffsetForIndex): number {\n    if (containerSize <= 0) {\n      return 0;\n    }\n\n    const datum = this.getSizeAndPositionOfCell(targetIndex);\n    const maxOffset = datum.offset;\n    const minOffset = maxOffset - containerSize + datum.size;\n\n    let idealOffset;\n\n    switch (align) {\n      case 'start':\n        idealOffset = maxOffset;\n        break;\n      case 'end':\n        idealOffset = minOffset;\n        break;\n      case 'center':\n        idealOffset = maxOffset - (containerSize - datum.size) / 2;\n        break;\n      default:\n        idealOffset = Math.max(minOffset, Math.min(maxOffset, currentOffset));\n        break;\n    }\n\n    const totalSize = this.getTotalSize();\n\n    return Math.max(0, Math.min(totalSize - containerSize, idealOffset));\n  }\n\n  getVisibleCellRange(params: GetVisibleCellRangeParams): VisibleCellRange {\n    if (this.getTotalSize() === 0) {\n      return {};\n    }\n\n    const { containerSize, offset } = params;\n    const maxOffset = offset + containerSize - 1;\n    return {\n      start: this._findNearestCell(offset),\n      stop: this._findNearestCell(maxOffset)\n    };\n  }\n\n  /**\n   * Clear all cached values for cells after the specified index.\n   * This method should be called for any cell that has changed its size.\n   * It will not immediately perform any calculations; they'll be performed the next time getSizeAndPositionOfCell() is called.\n   */\n  resetCell(index: number): void {\n    this._lastMeasuredIndex = Math.min(this._lastMeasuredIndex, index - 1);\n  }\n\n  /**\n   * Searches for the cell (index) nearest the specified offset.\n   *\n   * If no exact match is found the next lowest cell index will be returned.\n   * This allows partially visible cells (with offsets just before/above the fold) to be visible.\n   */\n  _findNearestCell(offset: number): number {\n    if (isNaN(offset)) {\n      throw Error(`Invalid offset ${offset} specified`);\n    }\n\n    const vector = this._layoutVector;\n    const lastIndex = this._cellCount - 1;\n    // Our search algorithms find the nearest match at or below the specified offset.\n    // So make sure the offset is at least 0 or no match will be found.\n    let targetOffset = Math.max(0, Math.min(offset, vector.start(lastIndex)));\n    // First interrogate the constant-time lookup table\n    let nearestCellIndex = vector.indexOf(targetOffset);\n\n    // If we haven't yet measured this high, compute sizes for each cell up to the desired offset.\n    while (nearestCellIndex > this._lastMeasuredIndex) {\n      // Measure all the cells up to the one we want to find presently.\n      // Do this before the last-index check to ensure the sparse array\n      // is fully populated.\n      this.getSizeAndPositionOfCell(nearestCellIndex);\n      // No need to search and compare again if we're at the end.\n      if (nearestCellIndex === lastIndex) {\n        return nearestCellIndex;\n      }\n      nearestCellIndex = vector.indexOf(targetOffset);\n      // Guard in case `getSizeAndPositionOfCell` didn't fully measure to\n      // the nearestCellIndex. This might happen scrolling quickly down\n      // and back up on large lists -- possible race with React or DOM?\n      if (nearestCellIndex === -1) {\n        nearestCellIndex = this._lastMeasuredIndex;\n        this._lastMeasuredIndex = nearestCellIndex - 1;\n        targetOffset = Math.max(0, Math.min(offset, vector.start(lastIndex)));\n      }\n    }\n\n    return nearestCellIndex;\n  }\n}\n"],"file":"CellSizeAndPositionManager.js"}