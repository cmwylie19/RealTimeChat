{"version":3,"sources":["../../../../../src/components/Virtualized/utils/updateScrollIndexHelper.ts"],"names":["updateScrollIndexHelper","cellSize","cellSizeAndPositionManager","previousCellsCount","previousCellSize","previousScrollToAlignment","previousScrollToIndex","previousSize","scrollOffset","scrollToAlignment","scrollToIndex","size","sizeJustIncreasedFromZero","updateScrollIndexCallback","cellCount","getCellCount","hasScrollToIndex","sizeHasChanged","getTotalSize"],"mappings":";;;;;;;AAIA;;;;AA2Ce,SAASA,uBAAT,OAcJ;AAAA,MAbTC,QAaS,QAbTA,QAaS;AAAA,MAZTC,0BAYS,QAZTA,0BAYS;AAAA,MAXTC,kBAWS,QAXTA,kBAWS;AAAA,MAVTC,gBAUS,QAVTA,gBAUS;AAAA,MATTC,yBASS,QATTA,yBASS;AAAA,MARTC,qBAQS,QARTA,qBAQS;AAAA,MAPTC,YAOS,QAPTA,YAOS;AAAA,MANTC,YAMS,QANTA,YAMS;AAAA,MALTC,iBAKS,QALTA,iBAKS;AAAA,MAJTC,aAIS,QAJTA,aAIS;AAAA,MAHTC,IAGS,QAHTA,IAGS;AAAA,MAFTC,yBAES,QAFTA,yBAES;AAAA,MADTC,yBACS,QADTA,yBACS;AACT,MAAMC,SAAS,GAAGZ,0BAA0B,CAACa,YAA3B,EAAlB;AACA,MAAMC,gBAAgB,GAAGN,aAAa,IAAI,CAAjB,IAAsBA,aAAa,GAAGI,SAA/D;AACA,MAAMG,cAAc,GAClBN,IAAI,KAAKJ,YAAT,IACAK,yBADA,IAEA,CAACR,gBAFD,IAGC,OAAOH,QAAP,KAAoB,QAApB,IAAgCA,QAAQ,KAAKG,gBAJhD,CAHS,CAST;AACA;;AACA,MACEY,gBAAgB,KACfC,cAAc,IAAIR,iBAAiB,KAAKJ,yBAAxC,IAAqEK,aAAa,KAAKJ,qBADxE,CADlB,EAGE;AACAO,IAAAA,yBAAyB,CAACH,aAAD,CAAzB,CADA,CAGA;AACA;AACD,GARD,MAQO,IAAI,CAACM,gBAAD,IAAqBF,SAAS,GAAG,CAAjC,KAAuCH,IAAI,GAAGJ,YAAP,IAAuBO,SAAS,GAAGX,kBAA1E,CAAJ,EAAmG;AACxG;AACA;AACA;AACA;AACA,QAAIK,YAAY,GAAGN,0BAA0B,CAACgB,YAA3B,KAA4CP,IAA/D,EAAqE;AACnEE,MAAAA,yBAAyB,CAACC,SAAS,GAAG,CAAb,CAAzB;AACD;AACF;AACF","sourcesContent":["import { Alignment, CellSize } from '../types';\n\nimport ScalingCellSizeAndPositionManager from './ScalingCellSizeAndPositionManager.js';\n\n/**\n * Helper function that determines when to update scroll offsets to ensure that a scroll-to-index remains visible.\n * This function also ensures that the scroll ofset isn't past the last column/row of cells.\n */\n\ninterface Params {\n  // Width or height of cells for the current axis\n  cellSize?: CellSize,\n\n  // Manages size and position metadata of cells\n  cellSizeAndPositionManager: ScalingCellSizeAndPositionManager,\n\n  // Previous number of rows or columns\n  previousCellsCount: number,\n\n  // Previous width or height of cells\n  previousCellSize: CellSize,\n\n  previousScrollToAlignment: Alignment,\n\n  // Previous scroll-to-index\n  previousScrollToIndex: number,\n\n  // Previous width or height of the virtualized container\n  previousSize: number,\n\n  // Current scrollLeft or scrollTop\n  scrollOffset: number,\n\n  scrollToAlignment: Alignment,\n\n  // Scroll-to-index\n  scrollToIndex: number,\n\n  // Width or height of the virtualized container\n  size: number,\n\n  sizeJustIncreasedFromZero: boolean,\n\n  // Callback to invoke with an scroll-to-index value\n  updateScrollIndexCallback: (index: number) => void\n}\n\nexport default function updateScrollIndexHelper({\n  cellSize,\n  cellSizeAndPositionManager,\n  previousCellsCount,\n  previousCellSize,\n  previousScrollToAlignment,\n  previousScrollToIndex,\n  previousSize,\n  scrollOffset,\n  scrollToAlignment,\n  scrollToIndex,\n  size,\n  sizeJustIncreasedFromZero,\n  updateScrollIndexCallback\n}: Params) {\n  const cellCount = cellSizeAndPositionManager.getCellCount();\n  const hasScrollToIndex = scrollToIndex >= 0 && scrollToIndex < cellCount;\n  const sizeHasChanged =\n    size !== previousSize ||\n    sizeJustIncreasedFromZero ||\n    !previousCellSize ||\n    (typeof cellSize === 'number' && cellSize !== previousCellSize);\n\n  // If we have a new scroll target OR if height/row-height has changed,\n  // We should ensure that the scroll target is visible.\n  if (\n    hasScrollToIndex &&\n    (sizeHasChanged || scrollToAlignment !== previousScrollToAlignment || scrollToIndex !== previousScrollToIndex)\n  ) {\n    updateScrollIndexCallback(scrollToIndex);\n\n    // If we don't have a selected item but list size or number of children have decreased,\n    // Make sure we aren't scrolled too far past the current content.\n  } else if (!hasScrollToIndex && cellCount > 0 && (size < previousSize || cellCount < previousCellsCount)) {\n    // We need to ensure that the current scroll offset is still within the collection's range.\n    // To do this, we don't need to measure everything; CellMeasurer would perform poorly.\n    // Just check to make sure we're still okay.\n    // Only adjust the scroll position if we've scrolled below the last set of rows.\n    if (scrollOffset > cellSizeAndPositionManager.getTotalSize() - size) {\n      updateScrollIndexCallback(cellCount - 1);\n    }\n  }\n}\n"],"file":"updateScrollIndexHelper.js"}