{"version":3,"sources":["../../../esm/components/Virtualized/defaultCellRangeRenderer.js"],"names":["defaultCellRangeRenderer","cellCache","cellRenderer","columnSizeAndPositionManager","columnStartIndex","columnStopIndex","deferredMeasurementCache","horizontalOffsetAdjustment","isScrolling","isScrollingOptOut","parent","rowSizeAndPositionManager","rowStartIndex","rowStopIndex","styleCache","verticalOffsetAdjustment","visibleColumnIndices","visibleRowIndices","renderedCells","areOffsetsAdjusted","canCacheStyle","rowIndex","rowDatum","getSizeAndPositionOfCell","columnIndex","columnDatum","isVisible","start","stop","key","style","has","height","left","position","top","width","size","offset","cellRendererParams","renderedCell","process","env","NODE_ENV","warnAboutMissingStyle","push","type","__internalCellMeasurerFlag","props","children","undefined","__warnedAboutMissingStyle","console","warn"],"mappings":"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","sourcesContent":["/* eslint-disable */\n\n/**\n * Default implementation of cellRangeRenderer used by Grid.\n * This renderer supports cell-caching while the user is scrolling.\n */\nexport default function defaultCellRangeRenderer({\n  cellCache,\n  cellRenderer,\n  columnSizeAndPositionManager,\n  columnStartIndex,\n  columnStopIndex,\n  deferredMeasurementCache,\n  horizontalOffsetAdjustment,\n  isScrolling,\n  isScrollingOptOut,\n  parent,\n  // Grid (or List or Table)\n  rowSizeAndPositionManager,\n  rowStartIndex,\n  rowStopIndex,\n  styleCache,\n  verticalOffsetAdjustment,\n  visibleColumnIndices,\n  visibleRowIndices\n}) {\n  const renderedCells = []; // Browsers have native size limits for elements (eg Chrome 33M pixels, IE 1.5M pixes).\n  // User cannot scroll beyond these size limitations.\n  // In order to work around this, ScalingCellSizeAndPositionManager compresses offsets.\n  // We should never cache styles for compressed offsets though as this can lead to bugs.\n  // See issue #576 for more.\n\n  const areOffsetsAdjusted = columnSizeAndPositionManager.areOffsetsAdjusted() || rowSizeAndPositionManager.areOffsetsAdjusted();\n  const canCacheStyle = !isScrolling && !areOffsetsAdjusted;\n\n  for (let rowIndex = rowStartIndex; rowIndex <= rowStopIndex; rowIndex++) {\n    const rowDatum = rowSizeAndPositionManager.getSizeAndPositionOfCell(rowIndex);\n\n    for (let columnIndex = columnStartIndex; columnIndex <= columnStopIndex; columnIndex++) {\n      const columnDatum = columnSizeAndPositionManager.getSizeAndPositionOfCell(columnIndex);\n      const isVisible = columnIndex >= visibleColumnIndices.start && columnIndex <= visibleColumnIndices.stop && rowIndex >= visibleRowIndices.start && rowIndex <= visibleRowIndices.stop;\n      const key = `${rowIndex}-${columnIndex}`;\n      let style; // Cache style objects so shallow-compare doesn't re-render unnecessarily.\n\n      if (canCacheStyle && styleCache[key]) {\n        style = styleCache[key];\n      } else {\n        // In deferred mode, cells will be initially rendered before we know their size.\n        // Don't interfere with CellMeasurer's measurements by setting an invalid size.\n        if (deferredMeasurementCache && !deferredMeasurementCache.has(rowIndex, columnIndex)) {\n          // Position not-yet-measured cells at top/left 0,0,\n          // And give them width/height of 'auto' so they can grow larger than the parent Grid if necessary.\n          // Positioning them further to the right/bottom influences their measured size.\n          style = {\n            height: 'auto',\n            left: 0,\n            position: 'absolute',\n            top: 0,\n            width: 'auto'\n          };\n        } else {\n          style = {\n            height: rowDatum.size,\n            left: columnDatum.offset + horizontalOffsetAdjustment,\n            position: 'absolute',\n            top: rowDatum.offset + verticalOffsetAdjustment,\n            width: columnDatum.size\n          };\n          styleCache[key] = style;\n        }\n      }\n\n      const cellRendererParams = {\n        columnIndex,\n        isScrolling,\n        isVisible,\n        key,\n        parent,\n        rowIndex,\n        style\n      };\n      let renderedCell; // Avoid re-creating cells while scrolling.\n      // This can lead to the same cell being created many times and can cause performance issues for \"heavy\" cells.\n      // If a scroll is in progress- cache and reuse cells.\n      // This cache will be thrown away once scrolling completes.\n      // However if we are scaling scroll positions and sizes, we should also avoid caching.\n      // This is because the offset changes slightly as scroll position changes and caching leads to stale values.\n      // For more info refer to issue #395\n      //\n      // If isScrollingOptOut is specified, we always cache cells.\n      // For more info refer to issue #1028\n\n      if ((isScrollingOptOut || isScrolling) && !horizontalOffsetAdjustment && !verticalOffsetAdjustment) {\n        if (!cellCache[key]) {\n          cellCache[key] = cellRenderer(cellRendererParams);\n        }\n\n        renderedCell = cellCache[key]; // If the user is no longer scrolling, don't cache cells.\n        // This makes dynamic cell content difficult for users and would also lead to a heavier memory footprint.\n      } else {\n        renderedCell = cellRenderer(cellRendererParams);\n      }\n\n      if (renderedCell == null || renderedCell === false) {\n        continue;\n      }\n\n      if (process.env.NODE_ENV !== 'production') {\n        warnAboutMissingStyle(parent, renderedCell);\n      }\n\n      renderedCells.push(renderedCell);\n    }\n  }\n\n  return renderedCells;\n}\n\nfunction warnAboutMissingStyle(parent, renderedCell) {\n  if (process.env.NODE_ENV !== 'production') {\n    if (renderedCell) {\n      // If the direct child is a CellMeasurer, then we should check its child\n      // See issue #611\n      if (renderedCell.type && renderedCell.type.__internalCellMeasurerFlag) {\n        renderedCell = renderedCell.props.children;\n      }\n\n      if (renderedCell && renderedCell.props && renderedCell.props.style === undefined && parent.__warnedAboutMissingStyle !== true) {\n        parent.__warnedAboutMissingStyle = true;\n        console.warn('Rendered cell should include style property for positioning.');\n      }\n    }\n  }\n}\n//# sourceMappingURL=defaultCellRangeRenderer.js.map"],"file":"defaultCellRangeRenderer.js"}