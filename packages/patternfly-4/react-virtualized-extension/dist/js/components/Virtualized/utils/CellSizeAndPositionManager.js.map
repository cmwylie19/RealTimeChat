{"version":3,"sources":["../../../../../src/components/Virtualized/utils/CellSizeAndPositionManager.ts"],"names":["CellSizeAndPositionManager","cellCount","cellSizeGetter","estimatedCellSize","_cellSizeGetter","_cellCount","_estimatedCellSize","_layoutVector","LinearLayoutVector","setLength","setDefaultSize","_lastMeasuredIndex","index","Error","vector","token","i","size","undefined","setItemSize","Math","min","offset","start","getItemSize","lastIndex","end","align","containerSize","currentOffset","targetIndex","datum","getSizeAndPositionOfCell","maxOffset","minOffset","idealOffset","max","totalSize","getTotalSize","params","_findNearestCell","stop","isNaN","targetOffset","nearestCellIndex","indexOf"],"mappings":"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","sourcesContent":["/* eslint-disable */\n\nimport LinearLayoutVector from 'linear-layout-vector';\nimport { Alignment, CellSizeGetter, VisibleCellRange } from '../types';\n\ninterface CellSizeAndPositionManagerParams {\n  cellCount: number,\n  cellSizeGetter: CellSizeGetter,\n  estimatedCellSize: number\n}\n\ninterface ConfigureParams {\n  cellCount: number,\n  estimatedCellSize: number,\n  cellSizeGetter: CellSizeGetter\n}\n\ninterface GetUpdatedOffsetForIndex {\n  align: Alignment,\n  containerSize: number,\n  currentOffset: number,\n  targetIndex: number\n}\n\ninterface GetVisibleCellRangeParams {\n  containerSize: number,\n  offset: number\n}\n\ninterface SizeAndPositionData {\n  offset: number,\n  size: number\n}\n\n/**\n * Just-in-time calculates and caches size and position information for a collection of cells.\n */\n\nexport default class CellSizeAndPositionManager {\n  // Cache of size and position data for cells, mapped by cell index.\n  // Note that invalid values may exist in this map so only rely on cells up to this._lastMeasuredIndex\n  _layoutVector;\n\n  // Measurements for cells up to this index can be trusted; cells afterward should be estimated.\n  _lastMeasuredIndex = -1;\n\n  _cellCount: number;\n  _cellSizeGetter: CellSizeGetter;\n  _estimatedCellSize: number;\n\n  constructor({ cellCount, cellSizeGetter, estimatedCellSize }: CellSizeAndPositionManagerParams) {\n    this._cellSizeGetter = cellSizeGetter;\n    this._cellCount = cellCount;\n    this._estimatedCellSize = estimatedCellSize;\n    this._layoutVector = new LinearLayoutVector();\n    this._layoutVector.setLength(cellCount);\n    this._layoutVector.setDefaultSize(estimatedCellSize);\n  }\n\n  areOffsetsAdjusted() {\n    return false;\n  }\n\n  configure({ cellCount, estimatedCellSize, cellSizeGetter }: ConfigureParams) {\n    this._cellCount = cellCount;\n    this._estimatedCellSize = estimatedCellSize;\n    this._cellSizeGetter = cellSizeGetter;\n    this._layoutVector.setLength(cellCount);\n    this._layoutVector.setDefaultSize(estimatedCellSize);\n  }\n\n  getCellCount(): number {\n    return this._cellCount;\n  }\n\n  getEstimatedCellSize(): number {\n    return this._estimatedCellSize;\n  }\n\n  getLastMeasuredIndex(): number {\n    return this._lastMeasuredIndex;\n  }\n\n  getOffsetAdjustment() {\n    return 0;\n  }\n\n  /**\n   * This method returns the size and position for the cell at the specified index.\n   * It just-in-time calculates (or used cached values) for cells leading up to the index.\n   */\n  getSizeAndPositionOfCell(index: number): SizeAndPositionData {\n    if (index < 0 || index >= this._cellCount) {\n      throw Error(`Requested index ${index} is outside of range 0..${this._cellCount}`);\n    }\n    const vector = this._layoutVector;\n    if (index > this._lastMeasuredIndex) {\n      const token = { index: this._lastMeasuredIndex + 1 };\n\n      for (let i = token.index; i <= index; token.index = ++i) {\n        const size = this._cellSizeGetter(token);\n        // undefined or NaN probably means a logic error in the size getter.\n        // null means we're using CellMeasurer and haven't yet measured a given index.\n        if (size === undefined || size !== size) {\n          throw Error(`Invalid size returned for cell ${i} of value ${size}`);\n        } else if (size !== null) {\n          vector.setItemSize(i, size);\n        }\n      }\n      this._lastMeasuredIndex = Math.min(index, this._cellCount - 1);\n    }\n\n    return {\n      offset: vector.start(index),\n      size: vector.getItemSize(index)\n    };\n  }\n\n  getSizeAndPositionOfLastMeasuredCell(): SizeAndPositionData {\n    const index = this._lastMeasuredIndex;\n    if (index <= 0) {\n      return {\n        offset: 0,\n        size: 0\n      };\n    }\n    const vector = this._layoutVector;\n    return {\n      offset: vector.start(index),\n      size: vector.getItemSize(index)\n    };\n  }\n\n  /**\n   * Total size of all cells being measured.\n   * This value will be completely estimated initially.\n   * As cells are measured, the estimate will be updated.\n   */\n  getTotalSize(): number {\n    const lastIndex = this._cellCount - 1;\n    return lastIndex >= 0 ? this._layoutVector.end(lastIndex) : 0;\n  }\n\n  /**\n   * Determines a new offset that ensures a certain cell is visible, given the current offset.\n   * If the cell is already visible then the current offset will be returned.\n   * If the current offset is too great or small, it will be adjusted just enough to ensure the specified index is visible.\n   *\n   * @param align Desired alignment within container; one of \"auto\" (default), \"start\", or \"end\"\n   * @param containerSize Size (width or height) of the container viewport\n   * @param currentOffset Container's current (x or y) offset\n   * @param totalSize Total size (width or height) of all cells\n   * @return Offset to use to ensure the specified cell is visible\n   */\n  getUpdatedOffsetForIndex({\n    align = 'auto',\n    containerSize,\n    currentOffset,\n    targetIndex\n  }: GetUpdatedOffsetForIndex): number {\n    if (containerSize <= 0) {\n      return 0;\n    }\n\n    const datum = this.getSizeAndPositionOfCell(targetIndex);\n    const maxOffset = datum.offset;\n    const minOffset = maxOffset - containerSize + datum.size;\n\n    let idealOffset;\n\n    switch (align) {\n      case 'start':\n        idealOffset = maxOffset;\n        break;\n      case 'end':\n        idealOffset = minOffset;\n        break;\n      case 'center':\n        idealOffset = maxOffset - (containerSize - datum.size) / 2;\n        break;\n      default:\n        idealOffset = Math.max(minOffset, Math.min(maxOffset, currentOffset));\n        break;\n    }\n\n    const totalSize = this.getTotalSize();\n\n    return Math.max(0, Math.min(totalSize - containerSize, idealOffset));\n  }\n\n  getVisibleCellRange(params: GetVisibleCellRangeParams): VisibleCellRange {\n    if (this.getTotalSize() === 0) {\n      return {};\n    }\n\n    const { containerSize, offset } = params;\n    const maxOffset = offset + containerSize - 1;\n    return {\n      start: this._findNearestCell(offset),\n      stop: this._findNearestCell(maxOffset)\n    };\n  }\n\n  /**\n   * Clear all cached values for cells after the specified index.\n   * This method should be called for any cell that has changed its size.\n   * It will not immediately perform any calculations; they'll be performed the next time getSizeAndPositionOfCell() is called.\n   */\n  resetCell(index: number): void {\n    this._lastMeasuredIndex = Math.min(this._lastMeasuredIndex, index - 1);\n  }\n\n  /**\n   * Searches for the cell (index) nearest the specified offset.\n   *\n   * If no exact match is found the next lowest cell index will be returned.\n   * This allows partially visible cells (with offsets just before/above the fold) to be visible.\n   */\n  _findNearestCell(offset: number): number {\n    if (isNaN(offset)) {\n      throw Error(`Invalid offset ${offset} specified`);\n    }\n\n    const vector = this._layoutVector;\n    const lastIndex = this._cellCount - 1;\n    // Our search algorithms find the nearest match at or below the specified offset.\n    // So make sure the offset is at least 0 or no match will be found.\n    let targetOffset = Math.max(0, Math.min(offset, vector.start(lastIndex)));\n    // First interrogate the constant-time lookup table\n    let nearestCellIndex = vector.indexOf(targetOffset);\n\n    // If we haven't yet measured this high, compute sizes for each cell up to the desired offset.\n    while (nearestCellIndex > this._lastMeasuredIndex) {\n      // Measure all the cells up to the one we want to find presently.\n      // Do this before the last-index check to ensure the sparse array\n      // is fully populated.\n      this.getSizeAndPositionOfCell(nearestCellIndex);\n      // No need to search and compare again if we're at the end.\n      if (nearestCellIndex === lastIndex) {\n        return nearestCellIndex;\n      }\n      nearestCellIndex = vector.indexOf(targetOffset);\n      // Guard in case `getSizeAndPositionOfCell` didn't fully measure to\n      // the nearestCellIndex. This might happen scrolling quickly down\n      // and back up on large lists -- possible race with React or DOM?\n      if (nearestCellIndex === -1) {\n        nearestCellIndex = this._lastMeasuredIndex;\n        this._lastMeasuredIndex = nearestCellIndex - 1;\n        targetOffset = Math.max(0, Math.min(offset, vector.start(lastIndex)));\n      }\n    }\n\n    return nearestCellIndex;\n  }\n}\n"],"file":"CellSizeAndPositionManager.js"}