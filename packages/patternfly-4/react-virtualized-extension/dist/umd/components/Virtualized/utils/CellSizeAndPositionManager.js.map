{"version":3,"sources":["../../../../esm/components/Virtualized/utils/CellSizeAndPositionManager.js"],"names":["_defineProperty","obj","key","value","Object","defineProperty","enumerable","configurable","writable","CellSizeAndPositionManager","constructor","cellCount","cellSizeGetter","estimatedCellSize","_cellSizeGetter","_cellCount","_estimatedCellSize","_layoutVector","LinearLayoutVector","setLength","setDefaultSize","areOffsetsAdjusted","configure","getCellCount","getEstimatedCellSize","getLastMeasuredIndex","_lastMeasuredIndex","getOffsetAdjustment","getSizeAndPositionOfCell","index","Error","vector","token","i","size","undefined","setItemSize","Math","min","offset","start","getItemSize","getSizeAndPositionOfLastMeasuredCell","getTotalSize","lastIndex","end","getUpdatedOffsetForIndex","align","containerSize","currentOffset","targetIndex","datum","maxOffset","minOffset","idealOffset","max","totalSize","getVisibleCellRange","params","_findNearestCell","stop","resetCell","isNaN","targetOffset","nearestCellIndex","indexOf"],"mappings":"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","sourcesContent":["function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/* eslint-disable */\nimport LinearLayoutVector from 'linear-layout-vector';\n\n/**\n * Just-in-time calculates and caches size and position information for a collection of cells.\n */\nexport default class CellSizeAndPositionManager {\n  // Cache of size and position data for cells, mapped by cell index.\n  // Note that invalid values may exist in this map so only rely on cells up to this._lastMeasuredIndex\n  // Measurements for cells up to this index can be trusted; cells afterward should be estimated.\n  constructor({\n    cellCount,\n    cellSizeGetter,\n    estimatedCellSize\n  }) {\n    _defineProperty(this, \"_lastMeasuredIndex\", -1);\n\n    this._cellSizeGetter = cellSizeGetter;\n    this._cellCount = cellCount;\n    this._estimatedCellSize = estimatedCellSize;\n    this._layoutVector = new LinearLayoutVector();\n\n    this._layoutVector.setLength(cellCount);\n\n    this._layoutVector.setDefaultSize(estimatedCellSize);\n  }\n\n  areOffsetsAdjusted() {\n    return false;\n  }\n\n  configure({\n    cellCount,\n    estimatedCellSize,\n    cellSizeGetter\n  }) {\n    this._cellCount = cellCount;\n    this._estimatedCellSize = estimatedCellSize;\n    this._cellSizeGetter = cellSizeGetter;\n\n    this._layoutVector.setLength(cellCount);\n\n    this._layoutVector.setDefaultSize(estimatedCellSize);\n  }\n\n  getCellCount() {\n    return this._cellCount;\n  }\n\n  getEstimatedCellSize() {\n    return this._estimatedCellSize;\n  }\n\n  getLastMeasuredIndex() {\n    return this._lastMeasuredIndex;\n  }\n\n  getOffsetAdjustment() {\n    return 0;\n  }\n  /**\n   * This method returns the size and position for the cell at the specified index.\n   * It just-in-time calculates (or used cached values) for cells leading up to the index.\n   */\n\n\n  getSizeAndPositionOfCell(index) {\n    if (index < 0 || index >= this._cellCount) {\n      throw Error(`Requested index ${index} is outside of range 0..${this._cellCount}`);\n    }\n\n    const vector = this._layoutVector;\n\n    if (index > this._lastMeasuredIndex) {\n      const token = {\n        index: this._lastMeasuredIndex + 1\n      };\n\n      for (let i = token.index; i <= index; token.index = ++i) {\n        const size = this._cellSizeGetter(token); // undefined or NaN probably means a logic error in the size getter.\n        // null means we're using CellMeasurer and haven't yet measured a given index.\n\n\n        if (size === undefined || size !== size) {\n          throw Error(`Invalid size returned for cell ${i} of value ${size}`);\n        } else if (size !== null) {\n          vector.setItemSize(i, size);\n        }\n      }\n\n      this._lastMeasuredIndex = Math.min(index, this._cellCount - 1);\n    }\n\n    return {\n      offset: vector.start(index),\n      size: vector.getItemSize(index)\n    };\n  }\n\n  getSizeAndPositionOfLastMeasuredCell() {\n    const index = this._lastMeasuredIndex;\n\n    if (index <= 0) {\n      return {\n        offset: 0,\n        size: 0\n      };\n    }\n\n    const vector = this._layoutVector;\n    return {\n      offset: vector.start(index),\n      size: vector.getItemSize(index)\n    };\n  }\n  /**\n   * Total size of all cells being measured.\n   * This value will be completely estimated initially.\n   * As cells are measured, the estimate will be updated.\n   */\n\n\n  getTotalSize() {\n    const lastIndex = this._cellCount - 1;\n    return lastIndex >= 0 ? this._layoutVector.end(lastIndex) : 0;\n  }\n  /**\n   * Determines a new offset that ensures a certain cell is visible, given the current offset.\n   * If the cell is already visible then the current offset will be returned.\n   * If the current offset is too great or small, it will be adjusted just enough to ensure the specified index is visible.\n   *\n   * @param align Desired alignment within container; one of \"auto\" (default), \"start\", or \"end\"\n   * @param containerSize Size (width or height) of the container viewport\n   * @param currentOffset Container's current (x or y) offset\n   * @param totalSize Total size (width or height) of all cells\n   * @return Offset to use to ensure the specified cell is visible\n   */\n\n\n  getUpdatedOffsetForIndex({\n    align = 'auto',\n    containerSize,\n    currentOffset,\n    targetIndex\n  }) {\n    if (containerSize <= 0) {\n      return 0;\n    }\n\n    const datum = this.getSizeAndPositionOfCell(targetIndex);\n    const maxOffset = datum.offset;\n    const minOffset = maxOffset - containerSize + datum.size;\n    let idealOffset;\n\n    switch (align) {\n      case 'start':\n        idealOffset = maxOffset;\n        break;\n\n      case 'end':\n        idealOffset = minOffset;\n        break;\n\n      case 'center':\n        idealOffset = maxOffset - (containerSize - datum.size) / 2;\n        break;\n\n      default:\n        idealOffset = Math.max(minOffset, Math.min(maxOffset, currentOffset));\n        break;\n    }\n\n    const totalSize = this.getTotalSize();\n    return Math.max(0, Math.min(totalSize - containerSize, idealOffset));\n  }\n\n  getVisibleCellRange(params) {\n    if (this.getTotalSize() === 0) {\n      return {};\n    }\n\n    const {\n      containerSize,\n      offset\n    } = params;\n    const maxOffset = offset + containerSize - 1;\n    return {\n      start: this._findNearestCell(offset),\n      stop: this._findNearestCell(maxOffset)\n    };\n  }\n  /**\n   * Clear all cached values for cells after the specified index.\n   * This method should be called for any cell that has changed its size.\n   * It will not immediately perform any calculations; they'll be performed the next time getSizeAndPositionOfCell() is called.\n   */\n\n\n  resetCell(index) {\n    this._lastMeasuredIndex = Math.min(this._lastMeasuredIndex, index - 1);\n  }\n  /**\n   * Searches for the cell (index) nearest the specified offset.\n   *\n   * If no exact match is found the next lowest cell index will be returned.\n   * This allows partially visible cells (with offsets just before/above the fold) to be visible.\n   */\n\n\n  _findNearestCell(offset) {\n    if (isNaN(offset)) {\n      throw Error(`Invalid offset ${offset} specified`);\n    }\n\n    const vector = this._layoutVector;\n    const lastIndex = this._cellCount - 1; // Our search algorithms find the nearest match at or below the specified offset.\n    // So make sure the offset is at least 0 or no match will be found.\n\n    let targetOffset = Math.max(0, Math.min(offset, vector.start(lastIndex))); // First interrogate the constant-time lookup table\n\n    let nearestCellIndex = vector.indexOf(targetOffset); // If we haven't yet measured this high, compute sizes for each cell up to the desired offset.\n\n    while (nearestCellIndex > this._lastMeasuredIndex) {\n      // Measure all the cells up to the one we want to find presently.\n      // Do this before the last-index check to ensure the sparse array\n      // is fully populated.\n      this.getSizeAndPositionOfCell(nearestCellIndex); // No need to search and compare again if we're at the end.\n\n      if (nearestCellIndex === lastIndex) {\n        return nearestCellIndex;\n      }\n\n      nearestCellIndex = vector.indexOf(targetOffset); // Guard in case `getSizeAndPositionOfCell` didn't fully measure to\n      // the nearestCellIndex. This might happen scrolling quickly down\n      // and back up on large lists -- possible race with React or DOM?\n\n      if (nearestCellIndex === -1) {\n        nearestCellIndex = this._lastMeasuredIndex;\n        this._lastMeasuredIndex = nearestCellIndex - 1;\n        targetOffset = Math.max(0, Math.min(offset, vector.start(lastIndex)));\n      }\n    }\n\n    return nearestCellIndex;\n  }\n\n}\n//# sourceMappingURL=CellSizeAndPositionManager.js.map"],"file":"CellSizeAndPositionManager.js"}