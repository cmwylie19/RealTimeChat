{"version":3,"sources":["../../../../src/components/ChartGroup/ChartGroup.tsx"],"names":["React","hoistNonReactStatics","VictoryGroup","VictoryZoomContainer","ChartContainer","getClassName","getTheme","ChartGroupSortOrder","ChartGroup","allowZoom","ariaDesc","ariaTitle","children","containerComponent","themeColor","themeVariant","theme","rest","container","cloneElement","desc","title","props","className","animate","categories","color","colorScale","data","domain","domainPadding","eventKey","events","externalEventMutations","groupComponent","height","horizontal","labelComponent","labels","maxDomain","x","y","minDomain","name","offset","origin"],"mappings":";;;;;;;;;;;;;;AAAA,OAAO,KAAKA,KAAZ,MAAuB,OAAvB;AACA,OAAOC,oBAAP,MAAiC,yBAAjC;AACA,SAcEC,YAdF,EAgBEC,oBAhBF,QAiBO,SAjBP;AAkBA,SAASC,cAAT,QAA+B,mBAA/B;AAEA,SAASC,YAAT,EAAuBC,QAAvB,QAAuC,eAAvC;AAEA,WAAYC,mBAAZ;AAKA;;;;WALYA,mB;AAAAA,EAAAA,mB;AAAAA,EAAAA,mB;GAAAA,mB,KAAAA,mB;;AA2XZ,OAAO,MAAMC,UAAoD,GAAG,UAY7C;AAAA,MAZ8C;AACnEC,IAAAA,SAAS,GAAG,KADuD;AAEnEC,IAAAA,QAFmE;AAGnEC,IAAAA,SAHmE;AAInEC,IAAAA,QAJmE;AAKnEC,IAAAA,kBAAkB,GAAGJ,SAAS,GAAG,oBAAC,oBAAD,OAAH,GAA8B,oBAAC,cAAD,OALO;AAMnEK,IAAAA,UANmE;AAOnEC,IAAAA,YAPmE;AASnE;AACAC,IAAAA,KAAK,GAAGV,QAAQ,CAACQ,UAAD,EAAaC,YAAb;AAVmD,GAY9C;AAAA,MADlBE,IACkB;;AACrB;AACA,QAAMC,SAAS,GAAGlB,KAAK,CAACmB,YAAN,CAAmBN,kBAAnB;AAChBO,IAAAA,IAAI,EAAEV,QADU;AAEhBW,IAAAA,KAAK,EAAEV,SAFS;AAGhBK,IAAAA;AAHgB,KAIbH,kBAAkB,CAACS,KAJN;AAKhBC,IAAAA,SAAS,EAAElB,YAAY,CAAC;AAACkB,MAAAA,SAAS,EAAEV,kBAAkB,CAACS,KAAnB,CAAyBC;AAArC,KAAD,CALP,CAKyD;;AALzD,KAAlB;AAOA,SAAO,oBAAC,YAAD;AAAc,IAAA,kBAAkB,EAAEL,SAAlC;AAA6C,IAAA,KAAK,EAAEF;AAApD,KAA+DC,IAA/D,GAAsEL,QAAtE,CAAP;AACD,CAtBM,C,CAwBP;;;AAnYEH,EAAAA,S;AAQAe,EAAAA,O;AAOAd,EAAAA,Q;AAOAC,EAAAA,S;AAQAc,EAAAA,U;AAIAb,EAAAA,Q;AAKAc,EAAAA,K;AAQAC,EAAAA,U;AAeAd,EAAAA,kB;AASAe,EAAAA,I;AASAC,EAAAA,M;AAOAC,EAAAA,a;AAKAC,EAAAA,Q;AAsCAC,EAAAA,M;AAIAC,EAAAA,sB;AAMAC,EAAAA,c;AAKAC,EAAAA,M;AAMAC,EAAAA,U;AAYAC,EAAAA,c;AASAC,EAAAA,M;AAeAC,EAAAA,S;AAAuBC,IAAAA,C;AAAYC,IAAAA,C;;AAenCC,EAAAA,S;AAAuBF,IAAAA,C;AAAYC,IAAAA,C;;AAInCE,EAAAA,I;AAOAC,EAAAA,M;AAKAC,EAAAA,M;AAAWL,IAAAA,C;AAAWC,IAAAA,C;;;AA0KxBxC,oBAAoB,CAACO,UAAD,EAAaN,YAAb,CAApB","sourcesContent":["import * as React from 'react';\nimport hoistNonReactStatics from 'hoist-non-react-statics';\nimport {\n  AnimatePropTypeInterface,\n  CategoryPropType,\n  ColorScalePropType,\n  D3Scale,\n  DataGetterPropType,\n  DomainPropType,\n  DomainPaddingPropType,\n  EventPropTypeInterface,\n  InterpolationPropType,\n  PaddingProps,\n  ScalePropType,\n  StringOrNumberOrCallback,\n  VictoryStyleInterface,\n  VictoryGroup,\n  VictoryGroupProps,\n  VictoryZoomContainer\n} from 'victory';\nimport { ChartContainer } from '../ChartContainer';\nimport { ChartThemeDefinition } from '../ChartTheme';\nimport { getClassName, getTheme } from '../ChartUtils';\n\nexport enum ChartGroupSortOrder {\n  ascending = 'ascending',\n  descending = 'descending'\n}\n\n/**\n * See https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/victory/index.d.ts\n */\nexport interface ChartGroupProps extends VictoryGroupProps {\n  /**\n   * Specifies the zoom capability of the container component. A value of true allows the chart to\n   * zoom in and out. Zoom events are controlled by scrolling. When zoomed in, panning events are\n   * controlled by dragging. By default this value is set to false.\n   *\n   * Note: Only compatible with charts that display an x, y axis\n   */\n  allowZoom?: boolean;\n  /**\n   * The animate prop specifies props for VictoryAnimation to use.\n   * The animate prop should also be used to specify enter and exit\n   * transition configurations with the `onExit` and `onEnter` namespaces respectively.\n   * @example\n   * {duration: 500, onExit: () => {}, onEnter: {duration: 500, before: () => ({y: 0})})}\n   */\n  animate?: AnimatePropTypeInterface;\n  /**\n   * The ariaDesc prop specifies the description of the chart/SVG to assist with\n   * accessibility for screen readers.\n   *\n   * Note: Overridden by the desc prop of containerComponent\n   */\n  ariaDesc?: string;\n  /**\n   * The ariaTitle prop specifies the title to be applied to the SVG to assist\n   * accessibility for screen readers.\n   *\n   * Note: Overridden by the title prop of containerComponent\n   */\n  ariaTitle?: string;\n  /**\n   * The categories prop specifies how categorical data for a chart should be ordered.\n   * This prop should be given as an array of string values, or an object with\n   * these arrays of values specified for x and y. If this prop is not set,\n   * categorical data will be plotted in the order it was given in the data array\n   * @example [\"dogs\", \"cats\", \"mice\"]\n   */\n  categories?: CategoryPropType;\n  /**\n   * The children to render with the chart\n   */\n  children?: React.ReactNode;\n  /**\n   * The color prop is an optional prop that defines a single color to be applied to the\n   * children of ChartGroup. The color prop will override colors specified via colorScale.\n   */\n  color?: string;\n  /**\n   * The colorScale prop is an optional prop that defines the color scale the chart's bars\n   * will be created on. This prop should be given as an array of CSS colors, or as a string\n   * corresponding to one of the built in color scales. ChartGroup will automatically assign\n   * values from this color scale to the bars unless colors are explicitly provided in the\n   * `dataAttributes` prop.\n   */\n  colorScale?: ColorScalePropType;\n  /**\n   * The containerComponent prop takes an entire component which will be used to\n   * create a container element for standalone charts.\n   * The new element created from the passed containerComponent wil be provided with\n   * these props from ChartGroup: height, width, children\n   * (the chart itself) and style. Props that are not provided by the\n   * child chart component include title and desc, both of which\n   * are intended to add accessibility to Victory components. The more descriptive these props\n   * are, the more accessible your data will be for people using screen readers.\n   * Any of these props may be overridden by passing in props to the supplied component,\n   * or modified or ignored within the custom component itself. If a dataComponent is\n   * not provided, ChartGroup will use the default ChartContainer component.\n   * @example <ChartContainer title=\"Chart of Dog Breeds\" desc=\"This chart shows...\" />\n   */\n  containerComponent?: React.ReactElement<any>;\n  /**\n   * The data prop specifies the data to be plotted. Data should be in the form of an array\n   * of data points, or an array of arrays of data points for multiple datasets.\n   * Each data point may be any format you wish (depending on the `x` and `y` accessor props),\n   * but by default, an object with x and y properties is expected.\n   * @example [{x: 1, y: 2}, {x: 2, y: 3}], [[1, 2], [2, 3]],\n   * [[{x: \"a\", y: 1}, {x: \"b\", y: 2}], [{x: \"a\", y: 2}, {x: \"b\", y: 3}]]\n   */\n  data?: any[];\n  /**\n   * The domain prop describes the range of values your chart will cover. This prop can be\n   * given as a array of the minimum and maximum expected values for your bar chart,\n   * or as an object that specifies separate arrays for x and y.\n   * If this prop is not provided, a domain will be calculated from data, or other\n   * available information.\n   * @example [-1, 1], {x: [0, 100], y: [0, 1]}\n   */\n  domain?: DomainPropType;\n  /**\n   * The domainPadding prop specifies a number of pixels of padding to add to the\n   * beginning and end of a domain. This prop is useful for explicitly spacing ticks farther\n   * from the origin to prevent crowding. This prop should be given as an object with\n   * numbers specified for x and y.\n   */\n  domainPadding?: DomainPaddingPropType;\n  /**\n   * Similar to data accessor props `x` and `y`, this prop may be used to functionally\n   * assign eventKeys to data\n   */\n  eventKey?: StringOrNumberOrCallback;\n  /**\n   * The event prop take an array of event objects. Event objects are composed of\n   * a target, an eventKey, and eventHandlers. Targets may be any valid style namespace\n   * for a given component, so \"data\" and \"labels\" are all valid targets for ChartGroup events.\n   * Since ChartGroup only renders a single element, the eventKey property is not used.\n   * The eventHandlers object should be given as an object whose keys are standard\n   * event names (i.e. onClick) and whose values are event callbacks. The return value\n   * of an event handler is used to modify elemnts. The return value should be given\n   * as an object or an array of objects with optional target and eventKey keys,\n   * and a mutation key whose value is a function. The target and eventKey keys\n   * will default to those corresponding to the element the event handler was attached to.\n   * The mutation function will be called with the calculated props for the individual selected\n   * element (i.e. an area), and the object returned from the mutation function\n   * will override the props of the selected element via object assignment.\n   * @example\n   * events={[\n   *   {\n   *     target: \"data\",\n   *     eventHandlers: {\n   *       onClick: () => {\n   *         return [\n   *            {\n   *              mutation: (props) => {\n   *                return {style: merge({}, props.style, {fill: \"orange\"})};\n   *              }\n   *            }, {\n   *              target: \"labels\",\n   *              mutation: () => {\n   *                return {text: \"hey\"};\n   *              }\n   *            }\n   *          ];\n   *       }\n   *     }\n   *   }\n   * ]}\n   */\n  events?: EventPropTypeInterface<'data' | 'labels' | 'parent', 'all'>[];\n  /**\n   * ChartGroup uses the standard externalEventMutations prop.\n   */\n  externalEventMutations?: any[];\n  /**\n   * The groupComponent prop takes an entire component which will be used to\n   * create group elements for use within container elements. This prop defaults\n   * to a <g> tag on web, and a react-native-svg <G> tag on mobile\n   */\n  groupComponent?: React.ReactElement<any>;\n  /**\n   * The height props specifies the height the svg viewBox of the chart container.\n   * This value should be given as a number of pixels\n   */\n  height?: number;\n  /**\n   * The horizontal prop determines whether data will be plotted horizontally.\n   * When this prop is set to true, the independent variable will be plotted on the y axis\n   * and the dependent variable will be plotted on the x axis.\n   */\n  horizontal?: boolean;\n  /**\n   * The labelComponent prop takes in an entire label component which will be used\n   * to create a label for the area. The new element created from the passed labelComponent\n   * will be supplied with the following properties: x, y, index, data, verticalAnchor,\n   * textAnchor, angle, style, text, and events. any of these props may be overridden\n   * by passing in props to the supplied component, or modified or ignored within\n   * the custom component itself. If labelComponent is omitted, a new ChartLabel\n   * will be created with props described above. This labelComponent prop should be used to\n   * provide a series label for ChartGroup. If individual labels are required for each\n   * data point, they should be created by composing ChartGroup with VictoryScatter\n   */\n  labelComponent?: React.ReactElement<any>;\n  /**\n   * The labels prop defines labels that will appear above each bar in your chart.\n   * This prop should be given as an array of values or as a function of data.\n   * If given as an array, the number of elements in the array should be equal to\n   * the length of the data array. Labels may also be added directly to the data object\n   * like data={[{x: 1, y: 1, label: \"first\"}]}.\n   * @example [\"spring\", \"summer\", \"fall\", \"winter\"], (datum) => datum.title\n   */\n  labels?: string[] | ((data: any) => string);\n  /**\n   * The maxDomain prop defines a maximum domain value for a chart. This prop is useful in situations where the maximum\n   * domain of a chart is static, while the minimum value depends on data or other variable information. If the domain\n   * prop is set in addition to maximumDomain, domain will be used.\n   *\n   * note: The x value supplied to the maxDomain prop refers to the independent variable, and the y value refers to the\n   * dependent variable. This may cause confusion in horizontal charts, as the independent variable will corresponds to\n   * the y axis.\n   *\n   * examples:\n   *\n   * maxDomain={0}\n   * maxDomain={{ y: 0 }}\n   */\n  maxDomain?: number | { x?: number, y?: number };\n  /**\n   * The minDomain prop defines a minimum domain value for a chart. This prop is useful in situations where the minimum\n   * domain of a chart is static, while the maximum value depends on data or other variable information. If the domain\n   * prop is set in addition to minimumDomain, domain will be used.\n   *\n   * note: The x value supplied to the minDomain prop refers to the independent variable, and the y value refers to the\n   * dependent variable. This may cause confusion in horizontal charts, as the independent variable will corresponds to\n   * the y axis.\n   *\n   * examples:\n   *\n   * minDomain={0}\n   * minDomain={{ y: 0 }}\n   */\n  minDomain?: number | { x?: number, y?: number };\n  /**\n   * The name prop is used to reference a component instance when defining shared events.\n   */\n  name?: string;\n  /**\n   * The offset prop determines the number of pixels each element in a group should\n   * be offset from its original position of the on the independent axis. In the\n   * case of groups of bars, this number should be equal to the width of the bar\n   * plus the desired spacing between bars.\n   */\n  offset?: number;\n  /**\n   * Victory components will pass an origin prop is to define the center point in svg coordinates for polar charts.\n   * **This prop should not be set manually.**\n   */\n  origin?: { x: number, y: number };\n  /**\n   * The padding props specifies the amount of padding in number of pixels between\n   * the edge of the chart and any rendered child components. This prop can be given\n   * as a number or as an object with padding specified for top, bottom, left\n   * and right.\n   */\n  padding?: PaddingProps;\n  /**\n   * Victory components can pass a boolean polar prop to specify whether a label is part of a polar chart.\n   * **This prop should not be set manually.**\n   */\n  polar?: boolean;\n  /**\n   * The range prop describes the dimensions over which data may be plotted. For cartesian coordinate systems, this\n   * corresponds to minimum and maximum svg coordinates in the x and y dimension. In polar coordinate systems this\n   * corresponds to a range of angles and radii. When this value is not given it will be calculated from the width,\n   * height, and padding, or from the startAngle and endAngle in the case of polar charts. All components in a given\n   * chart must share the same range, so setting this prop on children nested within Chart,\n   * ChartGroup will have no effect. This prop is usually not set manually.\n   *\n   * examples:\n   *\n   * Cartesian: range={{ x: [50, 250], y: [50, 250] }}\n   * Polar: range={{ x: [0, 360], y: [0, 250] }}\n   */\n  range?: [number, number] | { x?: [number, number], y?: [number, number] };\n  /**\n   * The samples prop specifies how many individual points to plot when plotting\n   * y as a function of x. Samples is ignored if x props are provided instead.\n   */\n  samples?: number;\n  /**\n   * The scale prop determines which scales your chart should use. This prop can be\n   * given as a string specifying a supported scale (\"linear\", \"time\", \"log\", \"sqrt\"),\n   * as a d3 scale function, or as an object with scales specified for x and y\n   * @example d3Scale.time(), {x: \"linear\", y: \"log\"}\n   */\n  scale?: ScalePropType | D3Scale | {\n    x?: ScalePropType | D3Scale;\n    y?: ScalePropType | D3Scale;\n  };\n  /**\n   * The sharedEvents prop is used internally to coordinate events between components. It should not be set manually.\n   */\n  sharedEvents?: any;\n  /**\n   * By default domainPadding is coerced to existing quadrants. This means that if a given domain only includes positive\n   * values, no amount of padding applied by domainPadding will result in a domain with negative values. This is the\n   * desired behavior in most cases. For users that need to apply padding without regard to quadrant, the\n   * singleQuadrantDomainPadding prop may be used. This prop may be given as a boolean or an object with boolean values\n   * specified for \"x\" and/or \"y\". When this prop is false (or false for a given dimension), padding will be applied\n   * without regard to quadrant. If this prop is not specified, domainPadding will be coerced to existing quadrants.\n   *\n   * note: The x value supplied to the singleQuadrantDomainPadding prop refers to the independent variable, and the y\n   * value refers to the dependent variable. This may cause confusion in horizontal charts, as the independent variable\n   * will corresponds to the y axis.\n   *\n   * examples:\n   *\n   * singleQuadrantDomainPadding={false}\n   * singleQuadrantDomainPadding={{ x: false }}\n   */\n  singleQuadrantDomainPadding?: boolean | { x: boolean, y: boolean };\n  /**\n   * Use the sortKey prop to indicate how data should be sorted. This prop\n   * is given directly to the lodash sortBy function to be executed on the\n   * final dataset.\n   */\n  sortKey?: string | string[] | Function;\n  /**\n   * The sortOrder prop specifies whether sorted data should be returned in ascending or descending order.\n   */\n  sortOrder?: 'ascending' | 'descending';\n  /**\n   * The standalone prop determines whether the component will render a standalone svg\n   * or a <g> tag that will be included in an external svg. Set standalone to false to\n   * compose ChartGroup with other components within an enclosing <svg> tag.\n   */\n  standalone?: boolean;\n  /**\n   * The style prop specifies styles for your ChartGroup. Any valid inline style properties\n   * will be applied. Height, width, and padding should be specified via the height,\n   * width, and padding props, as they are used to calculate the alignment of\n   * components within chart.\n   * @example {data: {fill: \"red\"}, labels: {fontSize: 12}}\n   */\n  style?: VictoryStyleInterface;\n  /**\n   * The theme prop specifies a theme to use for determining styles and layout properties for a component. Any styles or\n   * props defined in theme may be overwritten by props specified on the component instance.\n   */\n  theme?: ChartThemeDefinition;\n  /**\n   * Specifies the theme color. Valid values are 'blue', 'green', 'multi', etc.\n   *\n   * Note: Not compatible with theme prop\n   *\n   * @example themeColor={ChartThemeColor.blue}\n   */\n  themeColor?: string;\n  /**\n   * Specifies the theme variant. Valid values are 'dark' or 'light'\n   *\n   * Note: Not compatible with theme prop\n   *\n   * @example themeVariant={ChartThemeVariant.light}\n   */\n  themeVariant?: string;\n  /**\n   * The width props specifies the width of the svg viewBox of the chart container\n   * This value should be given as a number of pixels\n   */\n  width?: number;\n  /**\n   * The x prop specifies how to access the X value of each data point.\n   * If given as a function, it will be run on each data point, and returned value will be used.\n   * If given as an integer, it will be used as an array index for array-type data points.\n   * If given as a string, it will be used as a property key for object-type data points.\n   * If given as an array of strings, or a string containing dots or brackets,\n   * it will be used as a nested object property path (for details see Lodash docs for _.get).\n   * If `null` or `undefined`, the data value will be used as is (identity function/pass-through).\n   * @example 0, 'x', 'x.value.nested.1.thing', 'x[2].also.nested', null, d => Math.sin(d)\n   */\n  x?: DataGetterPropType;\n  /**\n   * The y prop specifies how to access the Y value of each data point.\n   * If given as a function, it will be run on each data point, and returned value will be used.\n   * If given as an integer, it will be used as an array index for array-type data points.\n   * If given as a string, it will be used as a property key for object-type data points.\n   * If given as an array of strings, or a string containing dots or brackets,\n   * it will be used as a nested object property path (for details see Lodash docs for _.get).\n   * If `null` or `undefined`, the data value will be used as is (identity function/pass-through).\n   * @example 0, 'y', 'y.value.nested.1.thing', 'y[2].also.nested', null, d => Math.sin(d)\n   */\n  y?: DataGetterPropType;\n  /**\n   * Use y0 data accessor prop to determine how the component defines the baseline y0 data.\n   * This prop is useful for defining custom baselines for components like ChartBar or ChartArea.\n   * This prop may be given in a variety of formats.\n   * @example 'last_quarter_profit', () => 10, 1, 'employees.salary', [\"employees\", \"salary\"]\n   */\n  y0?: DataGetterPropType;\n}\n\nexport const ChartGroup: React.FunctionComponent<ChartGroupProps> = ({\n  allowZoom = false,\n  ariaDesc,\n  ariaTitle,\n  children,\n  containerComponent = allowZoom ? <VictoryZoomContainer /> : <ChartContainer />,\n  themeColor,\n  themeVariant,\n\n  // destructure last\n  theme = getTheme(themeColor, themeVariant),\n  ...rest\n}: ChartGroupProps) => {\n  // Clone so users can override container props\n  const container = React.cloneElement(containerComponent, {\n    desc: ariaDesc,\n    title: ariaTitle,\n    theme,\n    ...containerComponent.props,\n    className: getClassName({className: containerComponent.props.className}) // Override VictoryContainer class name\n  });\n  return <VictoryGroup containerComponent={container} theme={theme} {...rest}>{children}</VictoryGroup>;\n};\n\n// Note: VictoryGroup.role must be hoisted\nhoistNonReactStatics(ChartGroup, VictoryGroup);\n"],"file":"ChartGroup.js"}