{"version":3,"sources":["../../../../esm/components/Virtualized/utils/updateScrollIndexHelper.js"],"names":["updateScrollIndexHelper","cellSize","cellSizeAndPositionManager","previousCellsCount","previousCellSize","previousScrollToAlignment","previousScrollToIndex","previousSize","scrollOffset","scrollToAlignment","scrollToIndex","size","sizeJustIncreasedFromZero","updateScrollIndexCallback","cellCount","getCellCount","hasScrollToIndex","sizeHasChanged","getTotalSize"],"mappings":";;;;;;;;;;;;;;;;;;oBAIwBA,uB;;AAJxB;;;;AAIe,WAASA,uBAAT,CAAiC;AAC9CC,IAAAA,QAD8C;AAE9CC,IAAAA,0BAF8C;AAG9CC,IAAAA,kBAH8C;AAI9CC,IAAAA,gBAJ8C;AAK9CC,IAAAA,yBAL8C;AAM9CC,IAAAA,qBAN8C;AAO9CC,IAAAA,YAP8C;AAQ9CC,IAAAA,YAR8C;AAS9CC,IAAAA,iBAT8C;AAU9CC,IAAAA,aAV8C;AAW9CC,IAAAA,IAX8C;AAY9CC,IAAAA,yBAZ8C;AAa9CC,IAAAA;AAb8C,GAAjC,EAcZ;AACD,UAAMC,SAAS,GAAGZ,0BAA0B,CAACa,YAA3B,EAAlB;AACA,UAAMC,gBAAgB,GAAGN,aAAa,IAAI,CAAjB,IAAsBA,aAAa,GAAGI,SAA/D;AACA,UAAMG,cAAc,GAAGN,IAAI,KAAKJ,YAAT,IAAyBK,yBAAzB,IAAsD,CAACR,gBAAvD,IAA2E,OAAOH,QAAP,KAAoB,QAApB,IAAgCA,QAAQ,KAAKG,gBAA/I,CAHC,CAGgK;AACjK;;AAEA,QAAIY,gBAAgB,KAAKC,cAAc,IAAIR,iBAAiB,KAAKJ,yBAAxC,IAAqEK,aAAa,KAAKJ,qBAA5F,CAApB,EAAwI;AACtIO,MAAAA,yBAAyB,CAACH,aAAD,CAAzB,CADsI,CAC5F;AAC1C;AACD,KAHD,MAGO,IAAI,CAACM,gBAAD,IAAqBF,SAAS,GAAG,CAAjC,KAAuCH,IAAI,GAAGJ,YAAP,IAAuBO,SAAS,GAAGX,kBAA1E,CAAJ,EAAmG;AACxG;AACA;AACA;AACA;AACA,UAAIK,YAAY,GAAGN,0BAA0B,CAACgB,YAA3B,KAA4CP,IAA/D,EAAqE;AACnEE,QAAAA,yBAAyB,CAACC,SAAS,GAAG,CAAb,CAAzB;AACD;AACF;AACF","sourcesContent":["/**\n * Helper function that determines when to update scroll offsets to ensure that a scroll-to-index remains visible.\n * This function also ensures that the scroll ofset isn't past the last column/row of cells.\n */\nexport default function updateScrollIndexHelper({\n  cellSize,\n  cellSizeAndPositionManager,\n  previousCellsCount,\n  previousCellSize,\n  previousScrollToAlignment,\n  previousScrollToIndex,\n  previousSize,\n  scrollOffset,\n  scrollToAlignment,\n  scrollToIndex,\n  size,\n  sizeJustIncreasedFromZero,\n  updateScrollIndexCallback\n}) {\n  const cellCount = cellSizeAndPositionManager.getCellCount();\n  const hasScrollToIndex = scrollToIndex >= 0 && scrollToIndex < cellCount;\n  const sizeHasChanged = size !== previousSize || sizeJustIncreasedFromZero || !previousCellSize || typeof cellSize === 'number' && cellSize !== previousCellSize; // If we have a new scroll target OR if height/row-height has changed,\n  // We should ensure that the scroll target is visible.\n\n  if (hasScrollToIndex && (sizeHasChanged || scrollToAlignment !== previousScrollToAlignment || scrollToIndex !== previousScrollToIndex)) {\n    updateScrollIndexCallback(scrollToIndex); // If we don't have a selected item but list size or number of children have decreased,\n    // Make sure we aren't scrolled too far past the current content.\n  } else if (!hasScrollToIndex && cellCount > 0 && (size < previousSize || cellCount < previousCellsCount)) {\n    // We need to ensure that the current scroll offset is still within the collection's range.\n    // To do this, we don't need to measure everything; CellMeasurer would perform poorly.\n    // Just check to make sure we're still okay.\n    // Only adjust the scroll position if we've scrolled below the last set of rows.\n    if (scrollOffset > cellSizeAndPositionManager.getTotalSize() - size) {\n      updateScrollIndexCallback(cellCount - 1);\n    }\n  }\n}\n//# sourceMappingURL=updateScrollIndexHelper.js.map"],"file":"updateScrollIndexHelper.js"}